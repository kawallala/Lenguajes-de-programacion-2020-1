<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0081)https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>1&nbsp;From Functions to Simple Objects</title><link rel="stylesheet" type="text/css" href="./1 From Functions to Simple Objects_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./1 From Functions to Simple Objects_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="./1 From Functions to Simple Objects_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="./1 From Functions to Simple Objects_files/manual-racket.css" title="default"><script type="text/javascript" src="./1 From Functions to Simple Objects_files/scribble-common.js.download"></script><script type="text/javascript" src="./1 From Functions to Simple Objects_files/manual-racket.js.download"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">▼</a></td><td></td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" class="tocviewlink" data-pltdoc="x">Object-<wbr>Oriented Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html" class="tocviewselflink" data-pltdoc="x">From Functions to Simple Objects</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" class="tocviewlink" data-pltdoc="x">Looking for the Self</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" class="tocviewlink" data-pltdoc="x">Benefits and Limits of Objects</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" class="tocviewlink" data-pltdoc="x">Forwarding and Delegation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Classes.html" class="tocviewlink" data-pltdoc="x">Classes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Inheritance.html" class="tocviewlink" data-pltdoc="x">Inheritance</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/A_World_of_Possibilities.html" class="tocviewlink" data-pltdoc="x">A World of Possibilities</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">►</a></td><td>1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html" class="tocviewselflink" data-pltdoc="x">From Functions to Simple Objects</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">1.1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._oopattern%29" class="tocviewlink" data-pltdoc="x">Stateful Functions and the Object Pattern</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.A__.First__.Simple_.Object_.System_in_.Scheme%29" class="tocviewlink" data-pltdoc="x">A (First) Simple Object System in Scheme</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._factory%29" class="tocviewlink" data-pltdoc="x">Constructing Objects</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.Dynamic_.Dispatch%29" class="tocviewlink" data-pltdoc="x">Dynamic Dispatch</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.Error_.Handling%29" class="tocviewlink" data-pltdoc="x">Error Handling</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._oopattern%29" class="tocsubseclink" data-pltdoc="x">Stateful Functions and the Object Pattern</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.A__.First__.Simple_.Object_.System_in_.Scheme%29" class="tocsubseclink" data-pltdoc="x">A (First) Simple Object System in Scheme</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._factory%29" class="tocsubseclink" data-pltdoc="x">Constructing Objects</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.Dynamic_.Dispatch%29" class="tocsubseclink" data-pltdoc="x">Dynamic Dispatch</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html#%28part._.Error_.Handling%29" class="tocsubseclink" data-pltdoc="x">Error Handling</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="backward to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" title="forward to &quot;2 Looking for the Self&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._.From_.Functions_to_.Simple_.Objects)"></a>From Functions to Simple Objects</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Éric Tanter</p></span></div><p>This exploration of object-oriented programming languages starts from what we know already from PLAI, as well as our intuition about what objects are.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._oopattern)"></a>Stateful Functions and the Object Pattern</h4><p>An object is meant to encapsulate in a coherent whole a piece of state (possibly, but not necessarily, mutable) together with some behavior that relies on that state. The state is usually called <span style="font-style: italic">fields</span> (or <span style="font-style: italic">instance variables</span>), and the behavior is provided as a set of <span style="font-style: italic">methods</span>. Calling a method is often considered as <span style="font-style: italic">message passing</span>: we send a message to an object, and if it understands it, it executes the associated method.</p><p></p><div class="SIntrapara">In higher-order procedural languages like Scheme, we have seen similar creatures:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">add</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">m</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">add2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">add2</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">7</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The function <span class="RktSym">add2</span> encapsulates some hidden state (<span class="RktSym">n</span><span class="stt"> </span><span class="RktSym">=</span><span class="stt"> </span><span class="RktVal">2</span>) and its behavior effectively depends on that state. So, in a sense, a closure is an object whose fields are its <span style="font-style: italic">free variables</span>. What about behavior? well, it has a unique behavior, triggered when the function is <span style="font-style: italic">applied</span> (from a message passing viewpoint, <span class="RktSym">apply</span> is the only message understood by a function).</div><p></p><p></p><div class="SIntrapara">If our language supports mutation (<span class="RktSym">set!</span>), we can effectively have a stateful function with changing state:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">counter</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">count</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">begin</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p>We can now effectively observe that the state of <span class="RktSym">counter</span> changes:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">counter</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">counter</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2</span></p></td></tr></tbody></table></blockquote><p>Now, what if we want a bi-directional counter?
The function must be able to do either +1 or -1 on its state depending on... well, an argument!</p><p></p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">counter</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">count</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cmd</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">case</span><span class="hspace">&nbsp;</span><span class="RktSym">cmd</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">dec</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">begin</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">sub1</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">inc</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">begin</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add1</span><span class="hspace">&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">count</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Note how <span class="RktSym">counter</span> uses <span class="RktSym">cmd</span> to discriminate what action to perform.</div><p></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">counter</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">inc</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">counter</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">dec</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">0</span></p></td></tr></tbody></table></blockquote><p>This looks quite like an object with two methods and one instance variable, doesn’t it?
Let’s look at another example, a stack.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">stack</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">vals</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">pop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">empty?</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"cannot pop from an empty stack"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">push</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">peek</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">empty?</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"cannot peek from an empty stack"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cmd</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">args</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">case</span><span class="hspace">&nbsp;</span><span class="RktSym">cmd</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">pop</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">pop</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">push</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">push</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">peek</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">peek</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">else</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"invalid command"</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Here, instead of writing each method body in place in the lambda, we use internal <span class="RktSym">define</span>s. Also note that we use the dot notation for the arguments of the lambda: this enables the function to receive one argument (the <span class="RktSym">cmd</span>) as well as zero or more extra arguments (available in the body as a list bound to <span class="RktSym">args</span>).</p><p>Let’s try that:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">push</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">push</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">pop</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">peek</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">pop</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">stack</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">pop</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">cannot pop from an empty stack</span></p></td></tr></tbody></table></blockquote><p>We can clearly see a code pattern that can be used to define object-like abstractions. In the following we abstract the pattern more clearly:</p><p></p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">methods</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">args</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assoc</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">methods</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Note how we are able to define the <span class="RktSym">λ</span> that dispatches to the correct method in a generic fashion. We first put all methods in an association list (ie. a list of pairs) associating a symbol (aka. message) to the corresponding method. When we apply <span class="RktSym">point</span>, we lookup (with <span class="RktSym">assoc</span>) the message and get the corresponding method. We then <span class="RktSym">apply</span> it.</div><p></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">point</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x!</span><span class="hspace">&nbsp;</span><span class="RktVal">6</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">point</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">6</span></p></td></tr></tbody></table></blockquote><h4>1.2<tt>&nbsp;</tt><a name="(part._.A__.First__.Simple_.Object_.System_in_.Scheme)"></a>A (First) Simple Object System in Scheme</h4><p></p><div class="SIntrapara">We can now use macros to embed a simple object system that follows the pattern identified above.
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Note that in this booklet, we use <a href="http://www.dcc.uchile.cl/etanter/defmac.rkt"><span class="RktSym">defmac</span></a> to define macros. <span class="RktSym">defmac</span> is like <span class="RktSym">define-syntax-rule</span>, but it also supports the specification of keywords and captures of identifiers (using the <span class="RktPn">#:keywords</span> and <span class="RktPn">#:captures</span> optional parameters).</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">mname</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:keywords</span><span class="hspace">&nbsp;</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">method</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">methods</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">mname</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assoc</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">methods</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">We can also define a specific notation for sending a message to an object, using an arrow <span class="RktSym"><span class="nobreak">-&gt;</span></span>, eg. <span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="stt"> </span><span class="RktSym">st</span><span class="stt"> </span><span class="RktSym">push</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">We can now use our embedded object system to define a bi-dimensional point object:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">p2D</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ny</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">ny</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">and use it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2D</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktVal">15</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2D</span><span class="hspace">&nbsp;</span><span class="RktSym">y!</span><span class="hspace">&nbsp;</span><span class="RktVal">20</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2D</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">15</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2D</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">20</span></p></td></tr></tbody></table></blockquote></div><p></p><h4>1.3<tt>&nbsp;</tt><a name="(part._factory)"></a>Constructing Objects</h4><p>Up to now, our objects have been created as unique specimen. What if we want more than one point object, possibly with different initial coordinates?</p><p></p><div class="SIntrapara">In the context of functional programming, we have already seen how to craft various similar functions in a proper way: we can use a higher-order function, parameterized accordingly, whose role is to produce the specific instances we want. For instance, from the <span class="RktSym">add</span> function defined previously, we can obtain various single-argument adder functions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">add4</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">add5</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">add4</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">add5</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">6</span></p></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">Because our simple object system is embedded in Scheme, we can simply reuse the power of higher-order functions to define <span style="font-style: italic">object factories</span>:
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>JavaScript, AmbientTalk</p></blockquote></blockquote></blockquote></div><p></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktSym">init-x</span><span class="hspace">&nbsp;</span><span class="RktSym">init-y</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktSym">init-x</span></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktSym">init-y</span></span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">new-x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">new-x</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">new-y</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">new-y</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>The <span class="RktSym">make-point</span> function takes the initial coordinates as parameter and returns a freshly created object, properly initialized.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktRes">10</span></p></td></tr></tbody></table></blockquote><h4>1.4<tt>&nbsp;</tt><a name="(part._.Dynamic_.Dispatch)"></a>Dynamic Dispatch</h4><p>Our simple object system is sufficient to show the fundamental aspect of object-oriented programming: dynamic dispatch. Notice how, in the following, a node sends the <span class="RktSym">sum</span> message to each of its children without knowing whether it is a leaf or a node:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-node</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">tree</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-node</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-node</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-node</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">tree</span><span class="hspace">&nbsp;</span><span class="RktSym">sum</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktRes">18</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote><p>As simple as it may seem, this object system is entirely enough to illustrate the fundamental abstraction mechanism that objects really are, as opposed to abstract data types. See the chapter on the <a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" data-pltdoc="x">benefits and limits of objects</a>.</p><h4>1.5<tt>&nbsp;</tt><a name="(part._.Error_.Handling)"></a>Error Handling</h4><p></p><div class="SIntrapara">Let us see what happens if we send a message to an object that does not know how to handle it:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">print</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktErr">cdr: contract violation</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">expected: pair?</span></p></td></tr><tr><td><p><span class="RktErr"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktErr">given: #f</span></p></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The error message is really not optimal—<wbr>it exposes our implementation strategy to the programmer, and does not really give a clue of what the actual problem is.</div><p></p><p></p><div class="SIntrapara">We can change the definition of the <span class="RktSym">OBJECT</span> syntactic abstraction to deal with unknown messages properly:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">mname</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:keywords</span><span class="hspace">&nbsp;</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">method</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">methods</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">mname</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">found</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assoc</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">methods</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktSym">found</span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">found</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">error</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktVal">"message not understood:"</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">msg</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p>Rather than assuming that the message will have an associated method in the method table of the object, we now first lookup and get the result as <span class="RktSym">found</span>, which will be <span class="RktVal">#f</span> if no method was found. In that case, we generate an informative error message.</p><p></p><div class="SIntrapara">This is much better indeed:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-leaf</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">print</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktErr">message not understood: print</span></p></td></tr></tbody></table></blockquote></div><p></p><p>In this section, we have successfully embedded a simple object system in Scheme that shows the connection between lexically-scoped first-class functions and objects. However, we are far from done, because the object system we have is still incomplete and primitive. </p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="backward to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" title="forward to &quot;2 Looking for the Self&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>