<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0055)https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>3&nbsp;Benefits and Limits of Objects</title><link rel="stylesheet" type="text/css" href="./3 Benefits and Limits of Objects_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./3 Benefits and Limits of Objects_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="./3 Benefits and Limits of Objects_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="./3 Benefits and Limits of Objects_files/manual-racket.css" title="default"><script type="text/javascript" src="./3 Benefits and Limits of Objects_files/scribble-common.js.download"></script><script type="text/javascript" src="./3 Benefits and Limits of Objects_files/manual-racket.js.download"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">▼</a></td><td></td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" class="tocviewlink" data-pltdoc="x">Object-<wbr>Oriented Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html" class="tocviewlink" data-pltdoc="x">From Functions to Simple Objects</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" class="tocviewlink" data-pltdoc="x">Looking for the Self</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" class="tocviewselflink" data-pltdoc="x">Benefits and Limits of Objects</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" class="tocviewlink" data-pltdoc="x">Forwarding and Delegation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Classes.html" class="tocviewlink" data-pltdoc="x">Classes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Inheritance.html" class="tocviewlink" data-pltdoc="x">Inheritance</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/A_World_of_Possibilities.html" class="tocviewlink" data-pltdoc="x">A World of Possibilities</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">►</a></td><td>3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" class="tocviewselflink" data-pltdoc="x">Benefits and Limits of Objects</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">3.1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Abstract_.Data_.Types%29" class="tocviewlink" data-pltdoc="x">Abstract Data Types</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Procedural_.Representations%29" class="tocviewlink" data-pltdoc="x">Procedural Representations</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Objects%29" class="tocviewlink" data-pltdoc="x">Objects</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.The_.Extensibility_.Problem%29" class="tocviewlink" data-pltdoc="x">The Extensibility Problem</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Different_.Forms_of_.Data_.Abstraction%29" class="tocviewlink" data-pltdoc="x">Different Forms of Data Abstraction</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Abstract_.Data_.Types%29" class="tocsubseclink" data-pltdoc="x">Abstract Data Types</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Procedural_.Representations%29" class="tocsubseclink" data-pltdoc="x">Procedural Representations</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Objects%29" class="tocsubseclink" data-pltdoc="x">Objects</a></td></tr><tr><td><span class="tocsublinknumber">3.3.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Object_.Interfaces%29" class="tocsubseclink" data-pltdoc="x">Object Interfaces</a></td></tr><tr><td><span class="tocsublinknumber">3.3.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Principles_of_.Object-.Oriented_.Programming%29" class="tocsubseclink" data-pltdoc="x">Principles of Object-<wbr>Oriented Programming</a></td></tr><tr><td><span class="tocsublinknumber">3.3.3<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Extensibility%29" class="tocsubseclink" data-pltdoc="x">Extensibility</a></td></tr><tr><td><span class="tocsublinknumber">3.3.4<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.What_about_.Java_%29" class="tocsubseclink" data-pltdoc="x">What about Java?</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.The_.Extensibility_.Problem%29" class="tocsubseclink" data-pltdoc="x">The Extensibility Problem</a></td></tr><tr><td><span class="tocsublinknumber">3.4.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.A.D.T%29" class="tocsubseclink" data-pltdoc="x">ADT</a></td></tr><tr><td><span class="tocsublinknumber">3.4.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.O.O.P%29" class="tocsubseclink" data-pltdoc="x">OOP</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html#%28part._.Different_.Forms_of_.Data_.Abstraction%29" class="tocsubseclink" data-pltdoc="x">Different Forms of Data Abstraction</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" title="backward to &quot;2 Looking for the Self&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" title="forward to &quot;4 Forwarding and Delegation&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._adt-oo)"></a>Benefits and Limits of Objects</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Éric Tanter</p></span></div><p>In the language course, we have been programming by defining a data type and its variants and then defining all the "services" over these structures using procedures that work by case analysis. This style of programming is sometimes called "procedural paradigm" or "functional design" (note that "functional" here does not refer to "side-effect free"!).</p><p>In PLAI, we have done this with <span class="RktSym">define-type</span> to introduce the data type and its variants, and using <span class="RktSym">type-case</span> in case-analyzing procedures. This procedural approach is common in other languages like C (unions), Pascal (variants), ML and Haskell’s algebraic data types, or plain Scheme’s tagged data.</p><p>So, what does object-oriented programming really bring us? What are its weaknesses? As it turns out, using an object-oriented language does not mean that programs are "object oriented". Many Java programs are not, or at least sacrifice some of the
fundamental benefits of objects.</p><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>This chapter is based on the article <span style="font-style: italic">On Understanding Data Abstraction, Revisited</span> by William R. Cook (2009).</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">The aim of this intermediary chapter is to step back from our step-by-step construction of OOP to contrast objects with the procedural approach, with the aim of clarifying the pros and cons of each approach. Interestingly, the simple object system we have built so far is entirely sufficient study the essential benefits and
limits of objects—<wbr>delegation, classes, inheritance, etc. are all interesting features, but are not <span style="font-style: italic">essential</span> to objects.</div><p></p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Abstract_.Data_.Types)"></a>Abstract Data Types</h4><p>Let us first look at abstract data types (ADTs). An ADT is a data type that hides its representation and only supplies operations to manipulate its values.</p><p></p><div class="SIntrapara">For instance, an <span style="font-style: italic">integer set</span> ADT can be defined as follows:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktSym">adt</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym">is</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">empty</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">Int</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">Bool</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">Int</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">Bool</span></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">There are many possible <span style="font-style: italic">representations</span> for such an integer set ADT. For instance, one could implement it with Scheme’s lists:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">null?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">null?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">car</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">The following client program can then use ADT values, without being aware of the underlying representation:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></tbody></table></blockquote></div><p></p><p>We could as well implement the set ADT with another representation, such as using PLAI’s <span class="RktSym">define-type</span> mechanism to create a variant type to encode a set as a linked list.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">mtSet</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">aSet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">next</span><span class="hspace">&nbsp;</span><span class="RktSym">Set?</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">mtSet</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">not</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">aSet</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">mtSet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">aSet</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">next</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">#t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">next</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara">The sample client program above runs exactly the same, even though the underlying representation is now changed:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></tbody></table></blockquote></div><p></p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Procedural_.Representations)"></a>Procedural Representations</h4><p>We can as well consider sets as being defined by their <span style="font-style: italic">characteristic function</span>: a function that, given a number, tells us whether or not this number is part of the set.
In that case, a set is simply a function <span class="RktSym">Int</span><span class="stt"> </span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="stt"> </span><span class="RktSym">Bool</span>. (In PLAI, we saw that in Chapter 11, when studying the <span style="font-style: italic">procedural representation</span> of environments.)</p><p></p><div class="SIntrapara">What is the characteristic function of the empty set? a function that always returns false. And the set obtained by inserting a new element?
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Because a set is represented by its characteristic function, <span class="RktSym">contains?</span> simply applies the function to the element. Note that the client program is again undisturbed:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">What do we gain with the procedural representation of sets? flexibility! For instance, we can define the set of all even numbers:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">even</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">even?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">It is not possible to fully represent this set in any of the ADT representations we considered above. (Why?) We can even define non-deterministic sets:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">random</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0.5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">With the procedural representation, we have much more freedom to define sets, and in addition, they can interoperate with existing set operations!
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">even</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">a</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktVal">12</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></tbody></table></blockquote></div><div class="SIntrapara">In contrast, with the ADT representations we have seen above, different representations <span style="font-style: italic">cannot</span> interoperate. A set-as-list value cannot be used by a set-as-struct operation, and vice versa. ADTs abstract the representation, but they only allow <span style="font-style: italic">a single representation</span> at a time.</div><p></p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Objects)"></a>Objects</h4><p>In essence, <span style="font-style: italic">sets as functions are objects</span>! Note that objects do <span style="font-style: italic">not</span> abstract type: the type of a set-as-function is very concrete: it is a function <span class="RktSym">Int</span><span class="stt"> </span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="stt"> </span><span class="RktSym">Bool</span>.
Of course, as we have seen in the first chapters, an object is a generalization of a function in that it can have multiple methods.</p><h5>3.3.1<tt>&nbsp;</tt><a name="(part._.Object_.Interfaces)"></a>Object Interfaces</h5><p></p><div class="SIntrapara">We can define a notion of <span style="font-style: italic">object interface</span> that gathers the signature of the methods of an object:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktSym">interface</span><span class="hspace">&nbsp;</span><span class="RktSym">Set</span><span class="hspace">&nbsp;</span><span class="RktSym">is</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Int</span><span class="hspace">&nbsp;</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">Bool</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktSym">:</span><span class="hspace">&nbsp;</span><span class="RktSym">Bool</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Let us use our simple object system to implement sets as objects:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eq?</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="hspace">&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">isEmpty?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Note that <span class="RktSym">empty</span> is an object, and <span class="RktSym">insert</span> is a factory function that returns objects. A set object implements the <span class="RktSym">Set</span> interface. The <span class="RktSym">empty</span> object does not contain any value, and <span class="RktSym">isEmpty?</span> returns <span class="RktVal">#t</span>. <span class="RktSym">insert</span> returns a new object whose <span class="RktSym">contains?</span> method is similar to the set characteristic function we have seen before, and <span class="RktSym">isEmpty?</span> returns <span class="RktVal">#f</span>.</div><p></p><p></p><div class="SIntrapara">A client program is unchanged for the set construction part, and then has to use message sending to interact with set objects:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">empty</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">insert</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">z</span><span class="hspace">&nbsp;</span><span class="RktSym">contains?</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">#t</span></p></td></tr></tbody></table></blockquote></div><p></p><p>Note that object interfaces are essentially higher-order types: methods are functions, so passing objects around means passing groups of functions around. This is a generalization of higher-order functional programming. Object-oriented programs are inherently higher-order.</p><h5>3.3.2<tt>&nbsp;</tt><a name="(part._.Principles_of_.Object-.Oriented_.Programming)"></a>Principles of Object-Oriented Programming</h5><p><span style="font-weight: bold">Principle:</span> <span style="font-style: italic">An object can only access other objects through their public interfaces</span></p><p>Once we create an object, like the one bound to <span class="RktSym">z</span> above, the <span style="font-style: italic">only</span> thing we can do with it is to interact by sending messages. We cannot "open it". No attribute of the object is visible, only its interface. In other words:</p><p><span style="font-weight: bold">Principle:</span> <span style="font-style: italic">An object can only have detailed knowledge about itself</span></p><p>This is fundamentally different from the way we program with ADT values: in a <span class="RktSym">type-case</span> analysis (recall the implementation of <span class="RktSym">contains?</span> in the ADT implementation with <span class="RktSym">define-type</span>), one is opening the value and gaining direct access to its attributes. ADTs provide encapsulation, but for the clients of the ADT; not for its implementation.
Objects go further in this regard. Even the implementation of the methods of an object cannot access attributes of objects other than itself.</p><p>From this we can derive another fundamental principle:</p><p><span style="font-weight: bold">Principle:</span> <span style="font-style: italic">An object is the set of observations that can be made upon it</span>, as defined by its object interface.</p><p>This is a strong principle, that says that if two objects behave the same for a certain experiment (ie., a number of observations), then they should be undistinguishable otherwise. This means that the use of identity-related operations (like pointer equality) are violating this principle of OOP. With <span class="RktSym">==</span> in Java, we can distinguish two objects that <span style="font-style: italic">are</span> different even though they <span style="font-style: italic">behave</span> in the same way.</p><h5>3.3.3<tt>&nbsp;</tt><a name="(part._.Extensibility)"></a>Extensibility</h5><p>The above principles can be considered the characteristic feature of OOP.
As Cook puts it: <span style="font-style: italic">"Any programming model that allows inspection of the representation of more than one abstraction at a time is NOT object oriented"</span></p><p>The Component Object Model (COM) is one of the purest OO programming model in practice. COM enforces all these principles: there is no built-in equality, there is no way to determine if an object is an instance of a given class. COM programs are therefore highly extensible.</p><p>Note that the extensibility of objects is in fact completely independent from inheritance! (We don’t even have classes in our language) It instead comes from the use of interfaces.</p><h5>3.3.4<tt>&nbsp;</tt><a name="(part._.What_about_.Java_)"></a>What about Java?</h5><p>Java is not a pure object-oriented language, not importantly because it has primitive types, but because it supports many operations that violate the principles we have described above. Java has primitive equality <span class="RktSym">==</span><span class="RktMeta"></span>, <span class="RktSym">instanceof</span><span class="RktMeta"></span>, casts to class types, that make it possible to distinguish two objects even though they behave the same. Java makes it possible to declare a method that accepts objects based on their classes, not their interfaces (in Java, a class name is also a type). And of course, Java allows objects to access the internals of other objects (public fields, of course, but even private fields are accessible by objects of the same class!).</p><p>This means that Java also supports ADT-style programming. There is no nothing wrong with that! But it is important to understand the design tradeoffs involved, to make an informed choice. For instance, in the JDK, certain classes respect OO principles on the surface (allowing extensibility), but in their implementation using ADT techniques (not extensible, but more efficient). If you’re interested, look at the <span class="RktSym">List</span><span class="RktMeta"></span> interface, and the <span class="RktSym">LinkedList</span><span class="RktMeta"></span> implementation.</p><p>Programming in "pure OO" in Java basically means not using class names as types (ie. use class names only after <span class="RktSym">new</span><span class="RktMeta"></span>), and never use primitive equality (<span class="RktSym">==</span><span class="RktMeta"></span>).</p><h4>3.4<tt>&nbsp;</tt><a name="(part._.The_.Extensibility_.Problem)"></a>The Extensibility Problem</h4><p>Object-oriented programming is often presented as the panacea in terms of extensible software. But what exactly is meant with "extensible"?</p><p>The extensibility problem is concerned with defining a data type (structure + operations) in a way that two kinds of extension are properly supported: adding new representational variants, or adding new operations.</p><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Here, we use the term ADT in line with Cook’s usage. It is important to clarify however that the discussion of the extensibility problem here actually contrasts objects with variant types (aka. algebraic data types). We are concerned with how to have an extensible <span style="font-style: italic">implementation</span>. The interface abstraction is not relevant here.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">As it turns out, ADTs and objects each nicely support one dimension of extensibility, but fail in the other. Let us study this with a well-known example: an interpreter of simple expressions.</div><p></p><h5>3.4.1<tt>&nbsp;</tt><a name="(part._.A.D.T)"></a>ADT</h5><p>We first consider the ADT approach. We define a data type for expressions with three variants:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">boolean?</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Now we can define the interpreter as a function that type-cases on the abstract syntax tree:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>This is good-old PLAI practice. With a little example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">6</span></p></td></tr></tbody></table></blockquote><p><span style="font-weight: bold">Extension: New Operation</span></p><p>Let us now consider that we want to add a new operation on expressions. In addition to interpret an expression, we want to typecheck an expression, that is, to determine the type of value it will produce (here, either <span class="RktSym">number</span><span class="RktMeta"></span> or <span class="RktSym">boolean</span><span class="RktMeta"></span>). This is fairly trivial in our case, but still makes it possible to detect without interpretation that a program is bound to fail because it adds things that are not both numbers:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">boolean</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: not a number"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara">We can determine the type of the program we defined previously:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'number</span></p></td></tr></tbody></table></blockquote></div><div class="SIntrapara">And see that our typechecker reject non-sensical programs:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">Type error: not a number</span></p></td></tr></tbody></table></blockquote></div><p></p><p>If we reflect on this extension case, we see that it all went smoothly. We wanted a new operation, and just had to define a new function. This extension is modular, because it is defined in a single place.</p><p><span style="font-weight: bold">Extension: New Data</span></p><p></p><div class="SIntrapara">We now turn to the other dimension of extensibility: adding new data variants. Suppose we want to extend our simple language with a new expression: <span class="RktSym">ifc</span>.
We extend the datatype definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define-type</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">number?</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="hspace">&nbsp;</span><span class="RktSym">boolean?</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr?</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">Changing the definition of <span class="RktSym">Expr</span> to add this new variant breaks all existing function definitions! <span class="RktSym">interp</span> and <span class="RktSym">typeof</span> are now invalid, because they type case on expressions, but do not include any case for <span class="RktSym">ifc</span>.
We need to modify them all to include the behavior associated to the <span class="RktSym">ifc</span> case:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-case</span><span class="hspace">&nbsp;</span><span class="RktSym">Expr</span><span class="hspace">&nbsp;</span><span class="RktSym">expr</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">boolean</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: not a number"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">boolean</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">type-t</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">type-t</span><span class="hspace">&nbsp;</span><span class="RktSym">type-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">type-t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: both branches should have same type"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: not a boolean"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p></p><div class="SIntrapara">This works:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr></tbody></table></blockquote></div><p></p><p>This extensibility scenario was much less favorable. We had to modify the datatype definition and all the functions.</p><p>To summarize, with ADTs, adding new operations (eg. <span class="RktSym">typeof</span>) is easy and modular, but adding new data variants (eg. <span class="RktSym">ifc</span>) is cumbersome and non-modular.</p><h5>3.4.2<tt>&nbsp;</tt><a name="(part._.O.O.P)"></a>OOP</h5><p>How do objects perform in these extensibility scenarios?</p><p>First, we start with the object-oriented version of our interpreter:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Note that, in line with OO design principles, each expression objects knows how to interpret itself. There is no more a centralized interpreter that deals with all expressions. Interpreting a program is done by sending the <span class="RktSym">interp</span> message to the program:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">prog</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">6</span></p></td></tr></tbody></table></blockquote><p><span style="font-weight: bold">Extension: New Data</span></p><p>Adding a new kind of data like a conditional <span class="RktSym">ifc</span> object can be done by simply defining a new object factory, with the definition of how these new objects handle the <span class="RktSym">interp</span> message:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara">We can now interpret programs with conditionals:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktRes">4</span></p></td></tr></tbody></table></blockquote></div><p></p><p>This case shows that, conversely to ADTs, adding new data variants with OOP is direct and modular: just create a new (kind of) object(s). This is a clear advantage of objects over ADTs.</p><p><span style="font-weight: bold">Extension: New Operation</span></p><p>But before concluding that OOP is the panacea for extensible software, we have to consider the other extension scenario: adding an operation. Suppose we now want to typecheck our programs, just as we did before. This means that expression objects should now also understand the <span class="RktVal">"typeof"</span> message. To do that, we actually have to modify all object definitions:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">b</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">boolean</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">and</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">number</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: not a number"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">interp</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">boolean</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">c</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">type-t</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">equal?</span><span class="hspace">&nbsp;</span><span class="RktSym">type-t</span><span class="hspace">&nbsp;</span><span class="RktSym">type-f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">type-t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: both branches should have same type"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"Type error: not a boolean"</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara">We can if this works:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'number</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ifc</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">bool</span><span class="hspace">&nbsp;</span><span class="RktVal">#f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">num</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">typeof</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">Type error: not a boolean</span></p></td></tr></tbody></table></blockquote></div><p></p><p>This extensibility scenario forced us to modify all our code to add the new methods.</p><p>To summarize, with objects, adding new data variants (eg. <span class="RktSym">ifc</span>) is easy and modular, but adding new operations (eg. <span class="RktSym">typeof</span>) is cumbersome and non-modular.</p><p>Note that this is just the dual situation of ADTs!</p><h4>3.5<tt>&nbsp;</tt><a name="(part._.Different_.Forms_of_.Data_.Abstraction)"></a>Different Forms of Data Abstraction</h4><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Cook’s paper goes more in depth in the comparison of these forms of data abstraction. It is definitely a must-read!</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">ADTs and objects are different forms of data abstraction, each with its own advantages and drawbacks.</div><p></p><p>ADTs have a private representation type that prohibits tampering and extension. This is good for reasoning (analysis) and optimization. But it only permits one representation at a time.</p><p>Objects have behavioral interfaces, which allow definition of new implementations at any time. This is good for flexibility and extensibility. But it makes it hard to analyze code, and makes certain optimizations impossible.</p><p>Both forms of abstraction also support different forms of modular extensions. It is possible to modularly add new operations on an ADT, but supporting new data variants is cumbersome. It is possible to modularly add new representations to an object-oriented system, but adding new operations implies crosscutting modifications.</p><p>There are ways to navigate this tradeoff. For instance, one can expose certain implementation details in the interface of an object. That sacrifices some extensibility, but recovers the possibility to do some optimizations. The fundamental question is therefore a design question: what do I really need?</p><p>Now you understand why many languages support both kinds of data abstraction.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" title="backward to &quot;2 Looking for the Self&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" title="forward to &quot;4 Forwarding and Delegation&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>