<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0074)https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>4&nbsp;Forwarding and Delegation</title><link rel="stylesheet" type="text/css" href="./4 Forwarding and Delegation_files/scribble.css" title="default"><link rel="stylesheet" type="text/css" href="./4 Forwarding and Delegation_files/racket.css" title="default"><link rel="stylesheet" type="text/css" href="./4 Forwarding and Delegation_files/manual-style.css" title="default"><link rel="stylesheet" type="text/css" href="./4 Forwarding and Delegation_files/manual-racket.css" title="default"><script type="text/javascript" src="./4 Forwarding and Delegation_files/scribble-common.js.download"></script><script type="text/javascript" src="./4 Forwarding and Delegation_files/manual-racket.js.download"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">▼</a></td><td></td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" class="tocviewlink" data-pltdoc="x">Object-<wbr>Oriented Programming Languages:<span class="mywbr"> &nbsp;</span> Application and Interpretation</a></td></tr></tbody></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/From_Functions_to_Simple_Objects.html" class="tocviewlink" data-pltdoc="x">From Functions to Simple Objects</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" class="tocviewlink" data-pltdoc="x">Looking for the Self</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" class="tocviewlink" data-pltdoc="x">Benefits and Limits of Objects</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" class="tocviewselflink" data-pltdoc="x">Forwarding and Delegation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Classes.html" class="tocviewlink" data-pltdoc="x">Classes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Inheritance.html" class="tocviewlink" data-pltdoc="x">Inheritance</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/A_World_of_Possibilities.html" class="tocviewlink" data-pltdoc="x">A World of Possibilities</a></td></tr></tbody></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tbody><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">►</a></td><td>4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html" class="tocviewselflink" data-pltdoc="x">Forwarding and Delegation</a></td></tr></tbody></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tbody><tr><td align="right">4.1&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Message_.Forwarding%29" class="tocviewlink" data-pltdoc="x">Message Forwarding</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Delegation%29" class="tocviewlink" data-pltdoc="x">Delegation</a></td></tr><tr><td align="right">4.3&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Programming_with_.Prototypes%29" class="tocviewlink" data-pltdoc="x">Programming with Prototypes</a></td></tr><tr><td align="right">4.4&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Late_.Binding_of_.Self_and_.Modularity%29" class="tocviewlink" data-pltdoc="x">Late Binding of Self and Modularity</a></td></tr><tr><td align="right">4.5&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Lexical_.Scope_and_.Delegation%29" class="tocviewlink" data-pltdoc="x">Lexical Scope and Delegation</a></td></tr><tr><td align="right">4.6&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Delegation_.Models%29" class="tocviewlink" data-pltdoc="x">Delegation Models</a></td></tr><tr><td align="right">4.7&nbsp;</td><td><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Cloning%29" class="tocviewlink" data-pltdoc="x">Cloning</a></td></tr></tbody></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tbody><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Message_.Forwarding%29" class="tocsubseclink" data-pltdoc="x">Message Forwarding</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Delegation%29" class="tocsubseclink" data-pltdoc="x">Delegation</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Programming_with_.Prototypes%29" class="tocsubseclink" data-pltdoc="x">Programming with Prototypes</a></td></tr><tr><td><span class="tocsublinknumber">4.3.1<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Singleton_and_.Exceptional_.Objects%29" class="tocsubseclink" data-pltdoc="x">Singleton and Exceptional Objects</a></td></tr><tr><td><span class="tocsublinknumber">4.3.2<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Sharing_through_.Delegation%29" class="tocsubseclink" data-pltdoc="x">Sharing through Delegation</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Late_.Binding_of_.Self_and_.Modularity%29" class="tocsubseclink" data-pltdoc="x">Late Binding of Self and Modularity</a></td></tr><tr><td><span class="tocsublinknumber">4.5<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Lexical_.Scope_and_.Delegation%29" class="tocsubseclink" data-pltdoc="x">Lexical Scope and Delegation</a></td></tr><tr><td><span class="tocsublinknumber">4.6<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Delegation_.Models%29" class="tocsubseclink" data-pltdoc="x">Delegation Models</a></td></tr><tr><td><span class="tocsublinknumber">4.7<tt>&nbsp;</tt></span><a href="https://users.dcc.uchile.cl/~etanter/ooplai/Forwarding_and_Delegation.html#%28part._.Cloning%29" class="tocsubseclink" data-pltdoc="x">Cloning</a></td></tr></tbody></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" title="backward to &quot;3 Benefits and Limits of Objects&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/Classes.html" title="forward to &quot;5 Classes&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._.Forwarding_and_.Delegation)"></a>Forwarding and Delegation</h3><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Éric Tanter</p></span></div><p>Using message sending, an object can always forward a message to another object in case it does not know how to handle it. With our small object system, we can do that explicitly as follows:</p><p></p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prod</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">case</span><span class="hspace">&nbsp;</span><span class="RktSym">prod</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">price1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">price2</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">200</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">provider</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prod</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">provider</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktSym">prod</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">200</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Object <span class="RktSym">broker</span> does not know how to compute the price of a product, but it can claim to do so by implementing a method to handle the <span class="RktSym">price</span> message, and simply forwarding it to <span class="RktSym">seller</span>, who does implement the desired behavior. Note how <span class="RktSym">broker</span> holds a reference to <span class="RktSym">seller</span> in its <span class="RktSym">provider</span> field. This is a typical example of object composition, with message forwarding.</div><p></p><p></p><div class="SIntrapara">Now, you can see that the problem with this approach is that this forwarding of messages has to be explicit: for each message that we anticipate might be sent to <span class="RktSym">broker</span>, we have to define a method that forwards the message to <span class="RktSym">seller</span>. For instance:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktErr">message not understood: unit</span></p></td></tr></tbody></table></blockquote></div><p></p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Message_.Forwarding)"></a>Message Forwarding</h4><p>We can do better by allowing each object to have a special "partner" object to which it automatically forwards any message it does not understand. We can define a new syntactic abstraction, <span class="RktSym">OBJECT-FWD</span>, for constructing such objects:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-FWD</span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktSym">target</span></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">mname</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:keywords</span><span class="hspace">&nbsp;</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">method</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:captures</span><span class="hspace">&nbsp;</span><span class="RktSym">self</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">letrec</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">self</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">methods</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">mname</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">found</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assoc</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">methods</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktSym">found</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">found</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">apply</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">target</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">msg</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">vals</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">self</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Note how the syntax is extended to specify a <span class="RktSym">target</span> object; this object is used in the dispatch process whenever a message is not found in the methods of the object. Of course, if all objects forward unknown message to some other object, there has to be a last object in the chain, that simply fails when sent a message:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">args</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">error</span><span class="hspace">&nbsp;</span><span class="RktVal">"not understood"</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Now, <span class="RktSym">broker</span> can be defined simply as follows:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-FWD</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara">That is, <span class="RktSym">broker</span> is an empty object (no fields, no methods) that forwards all messages sent to it to <span class="RktSym">seller</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">200</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr></tbody></table></blockquote></div><div class="SIntrapara">This kind of objects is often called a <span style="font-style: italic">proxy</span>.</div><p></p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Delegation)"></a>Delegation</h4><p>Suppose we want to use <span class="RktSym">broker</span> to <span style="font-style: italic">refine</span> the behavior of <span class="RktSym">seller</span>; say, we want to double the price of every product, by changing the unit used in the calculation of the prices. This is easy: we just have to define a method <span class="RktSym">unit</span> in <span class="RktSym">broker</span>:</p><p></p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-FWD</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">With this definition, we should make sure that asking the price of a product to <span class="RktSym">broker</span> is twice the price of the same product asked to <span class="RktSym">seller</span>:</div><p></p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">100</span></p></td></tr></tbody></table></blockquote><p>Hmmm... it does not work! It seems that once we forward the <span class="RktSym">price</span> message to <span class="RktSym">seller</span>, <span class="RktSym">broker</span> never gets the control back; in particular, the <span class="RktSym">unit</span> message that <span class="RktSym">seller</span> sends to <span class="RktSym">self</span> is <span style="font-style: italic">not</span> received by <span class="RktSym">broker</span>.</p><p>Let us consider why this is so. To which object is <span class="RktSym">self</span> bound in <span class="RktSym">seller</span>? To <span class="RktSym">seller</span>! Remember, we said previously (see <a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html" data-pltdoc="x">Looking for the Self</a>) that in our approach, <span class="RktSym">self</span> is <span style="font-style: italic">statically bound</span>: when an object is created, <span class="RktSym">self</span> is made to refer to the object/closure that is being defined, and will always remain bound to it. This is because <span class="RktSym">letrec</span>, like <span class="RktSym">let</span>, respects lexical scoping.</p><p>What we are looking for is another semantics, called <span style="font-style: italic">delegation</span>. Delegation requires <span class="RktSym">self</span> in an object to be <span style="font-style: italic">dynamically bound</span>: it should always refer to the object that originally received the message. In our example, this would ensure that when <span class="RktSym">seller</span> sends <span class="RktSym">unit</span> to <span class="RktSym">self</span>, then <span class="RktSym">self</span> is bound to <span class="RktSym">broker</span>, and thus the re-definition of <span class="RktSym">unit</span> in <span class="RktSym">broker</span> takes effect. In that case, we say that <span class="RktSym">seller</span> is the <span style="font-style: italic">parent</span> of <span class="RktSym">broker</span>, and that <span class="RktSym">broker</span> <span style="font-style: italic">delegates</span> to its parent.</p><p>How do we bind an identifier such that it refers to the value at the point of usage, rather than at the point of definition? In the absence of dynamically-scoped binding forms, the only way we can achieve this is by passing that value as parameter. So, we have to parameterize methods by the actual receiver. Therefore, instead of capturing the <span class="RktSym">self</span> identifier in their surrounding lexical scope, they are parameterized by <span class="RktSym">self</span>.</p><p>Concretely, this means that the method:</p><p><span class="RktPn">(</span><span class="RktSym">λ</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">prod</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">....</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="stt"> </span><span class="RktSym">self</span><span class="stt"> </span><span class="RktSym">unit</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">....</span><span class="RktPn">)</span></p><p>in <span class="RktSym">seller</span> must be kept in the methods list as:</p><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Ever wondered why methods in Python must explicitly receive <span class="RktSym">self</span> as a first parameter?</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">self</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prod</span><span class="RktPn">)</span><span class="RktSym">....</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="RktPn">)</span><span class="RktSym">....</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p>This parameterization effectively allows us to pass the current receiver after we lookup the method.</p><p></p><div class="SIntrapara">Let us now define a new syntactic form, <span class="RktSym">OBJECT-DEL</span>, to support the delegation semantics between objects:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">parent</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">mname</span><span class="hspace">&nbsp;</span><span class="RktSym">args</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:keywords</span><span class="hspace">&nbsp;</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">method</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:captures</span><span class="hspace">&nbsp;</span><span class="RktSym">self</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">fname</span><span class="hspace">&nbsp;</span><span class="RktSym">init</span><span class="RktPn">]</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">methods</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">list</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cons</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">mname</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">λ</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">self</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">λ</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">args</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">body</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="highlighted"><span class="RktSym">current</span></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">found</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assoc</span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">methods</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktSym">found</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">cdr</span><span class="hspace">&nbsp;</span><span class="RktSym">found</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">current</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply</span><span class="hspace">&nbsp;</span><span class="highlighted"><span class="RktPn">(</span></span><span class="highlighted"><span class="RktSym">parent</span></span><span class="highlighted"><span class="hspace">&nbsp;</span></span><span class="highlighted"><span class="RktSym">current</span></span><span class="highlighted"><span class="RktPn">)</span></span><span class="hspace">&nbsp;</span><span class="RktSym">msg</span><span class="hspace">&nbsp;</span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p>Several things have changed: first, we renamed <span class="RktSym">target</span> to <span class="RktSym">parent</span>, to make it clear that we are defining a delegation semantics. Second, all methods are now parameterized by <span class="RktSym">self</span>, as explained above.
Note that we got rid of <span class="RktSym">letrec</span> altogether! This is because <span class="RktSym">letrec</span> was used precisely to allow objects to refer to <span class="RktSym">self</span>, but following lexical scoping. We have seen that for delegation, lexical scoping is not what we want.</p><p>This means that when we find a method in the method dictionary, we must first give it the actual receiver as argument. How are we going to obtain that receiver? well, the only possiblity is to parameterize objects by the current receiver they have to use when applying methods. That is to say, the value returned by the object construction form is not a "<span class="RktSym">λ</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">vals</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">....</span>" anymore, but a "<span class="RktSym">λ</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">rcvr</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">....</span>". This effectively parameterizes our objects by "the current receiver". Similarly, if a message is not understood by a given object, then it must send the current receiver along to its parent.</p><p></p><div class="SIntrapara">This leaves us with one final question to address: how do we send a message to an object in the first place?
Remember that our definition of <span class="RktSym"><span class="nobreak">-&gt;</span></span> is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">But now we cannot apply <span class="RktSym">o</span> as a function that takes a symbol (the message) and a variable number of arguments. Indeed, an object now is a function of the form <span class="RktPn">(</span><span class="RktSym">λ</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">rcvr</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">msg</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">args</span><span class="RktPn">)</span><span class="stt"> </span><span class="RktSym">....</span><span class="RktPn">)</span><span class="RktPn">)</span>. So before we can pass the message and the arguments, we have to specify which object is the current receiver. Well, it’s easy, because at the time we are sending a message, the current receiver should be... the object we are sending the message to!
</div><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Why is the <span class="RktSym">let</span> binding necessary?</p></blockquote></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">defmac</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="hspace">&nbsp;</span><span class="RktSym">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">obj</span><span class="hspace">&nbsp;</span><span class="RktSym">o</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">obj</span><span class="hspace">&nbsp;</span><span class="RktSym">obj</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">m</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><p></p><p>Let us see delegation—<wbr>that is, late binding of self—<wbr>at work:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prod</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">case</span><span class="hspace">&nbsp;</span><span class="RktSym">prod</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">price1</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">price2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">100</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">price2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">200</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">unit</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">seller</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">100</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">broker</span><span class="hspace">&nbsp;</span><span class="RktSym">price</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">200</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote><h4>4.3<tt>&nbsp;</tt><a name="(part._.Programming_with_.Prototypes)"></a>Programming with Prototypes</h4><p>Object-based languages with a delegation mechanism like the one we have introduced in this chapter are called <span style="font-style: italic">prototype-based languages</span>. Examples are Self, JavaScript, and AmbientTalk, among many others.
What are these languages good at? How to program with prototypes?</p><h5>4.3.1<tt>&nbsp;</tt><a name="(part._.Singleton_and_.Exceptional_.Objects)"></a>Singleton and Exceptional Objects</h5><p>Since objects can be created <span style="font-style: italic">ex-nihilo</span> (ie. out of an object literal expression like <span class="RktSym">OBJECT-DEL</span>), it is natural to create one-of-a-kind objects. As opposed to class-based languages that require a specific design pattern for this (called Singleton), object-based languages are a natural fit for this case, as well as for creating "exceptional" objects (more on this below).</p><p>Let us first consider the object-oriented representation of booleans and a simple if-then-else control structure. How many booleans are there? well, two: true, and false. So we can create two standalone objects, <span class="RktSym">true</span> and <span class="RktSym">false</span> to represent them. In pure object-oriented languages like Self and Smalltalk, control structures like if-then-else, while, etc. are not primitives in the language. Rather, they are defined as methods on appropriate objects. Let us consider the if-then-else case. We can pass two thunks to a boolean, a truth thunk and a falsity thunk; if the boolean <span style="font-style: italic">is</span> true, it applies the truth thunk; if it <span style="font-style: italic">is</span> false, it applies the falsity thunk.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">ifTrueFalse</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">ifTrueFalse</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>How can we use such objects? Look at the following example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">light</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">on</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">turn-on</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">on</span><span class="hspace">&nbsp;</span><span class="RktSym">true</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">turn-off</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">on</span><span class="hspace">&nbsp;</span><span class="RktSym">false</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">on?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">on</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">light</span><span class="hspace">&nbsp;</span><span class="RktSym">on?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ifTrueFalse</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"light is on"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"light is off"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktRes">"light is off"</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">light</span><span class="hspace">&nbsp;</span><span class="RktSym">turn-on</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">light</span><span class="hspace">&nbsp;</span><span class="RktSym">on?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ifTrueFalse</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"light is on"</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">"light is off"</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p><span class="RktRes">"light is on"</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote><p>The objects <span class="RktSym">true</span> and <span class="RktSym">false</span> are the two unique representants of boolean values. Any conditional mechanism that relies on some expression being true or false can be similarly defined as methods of these objects. This is indeed a nice example of dynamic dispatch!</p><p>Boolean values and control structures in Smalltalk are defined similarly, but because Smalltalk is a class-based language, their definitions are more complex. Try it in your favorite class-based language.</p><p>Let us look at another example where object-based languages are practical: exceptional objects.
First, recall the definition of typical point objects, which can be created using a factory function <span class="RktSym">make-point</span>:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>Suppose we want to introduce an exceptional point object that has the particularity of having <span style="font-style: italic">random</span> coordinates, that change each time they are accessed. We can simply define this <span class="RktSym">random-point</span> as a standalone object whose <span class="RktSym">x?</span> and <span class="RktSym">y?</span> methods perform some computation, rather than accessing stored state:</p><p></p><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">random-point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">Note that <span class="RktSym">random-point</span> does not have any fields declared. Of course, because in OOP we rely on object interfaces, both representations of points can coexist.</div><p></p><h5>4.3.2<tt>&nbsp;</tt><a name="(part._.Sharing_through_.Delegation)"></a>Sharing through Delegation</h5><p>The examples discussed above highlight the advantages of object-based languages. Let us now look at delegation in practice. First, delegation can be used to factor out <span style="font-style: italic">shared behavior</span> between objects. Consider the following:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">above</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">p2</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">self</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>All created point objects have the same methods, so this behavior could be shared by moving it to a common parent of all point objects (often called a prototype). Should all behavior be moved in the prototype? well, not if we want to allow different representations of points, like the random point above (which does not have any field at all!).</p><p>Therefore, we can define a <span class="RktSym">point</span> prototype, which factors out the <span class="RktSym">above</span> and <span class="RktSym">add</span> methods, whose implementation is common to all points:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">above</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">if</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&gt;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">p2</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">self</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">p2</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">+</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The required accessor methods could be declared as <span class="RktSym">abstract</span> methods in <span class="RktSym">point</span>, if our language supported such a concept. In Smalltalk, one would define the methods in <span class="RktSym">point</span> such that they throw an exception if invoked.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">Note that as a standalone object, <span class="RktSym">point</span> does not make sense, because it sends messages to itself that it does not understand. But it can serve as a prototype from which different points can extend. Some are typical points, created with <span class="RktSym">make-point</span>, which hold two fields <span class="RktSym">x</span> and <span class="RktSym">y</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">x-init</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">While some can be exceptional points:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">random-point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">point</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">random</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote></div><div class="SIntrapara">As we said, these different kinds of point can cooperate, and they all understand the messages defined in the <span class="RktSym">point</span> prototype:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">random-point</span><span class="hspace">&nbsp;</span><span class="RktSym">add</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">above</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">7.0578419826997285</span></p></td></tr></tbody></table></blockquote></div><p></p><p>We can similarly use delegation to share <span style="font-style: italic">state</span> between objects. For instance, consider a family of points that share the same x-coordinate:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">1D-point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">5</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">nx</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point-shared</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">1D-point</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">y-init</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">y!</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ny</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">set!</span><span class="hspace">&nbsp;</span><span class="RktSym">y</span><span class="hspace">&nbsp;</span><span class="RktSym">ny</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></blockquote><p>All objects created by <span class="RktSym">make-point-shared</span> share the same parent, <span class="RktSym">1D-point</span>, which determines their x-coordinate. If a change to <span class="RktSym">1D-point</span> is made, it is naturally reflected in all its children:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point-shared</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">make-point-shared</span><span class="hspace">&nbsp;</span><span class="RktVal">4</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">5</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">1D-point</span><span class="hspace">&nbsp;</span><span class="RktSym">x!</span><span class="hspace">&nbsp;</span><span class="RktVal">10</span><span class="RktPn">)</span></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p1</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">10</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">p2</span><span class="hspace">&nbsp;</span><span class="RktSym">x?</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">10</span></p></td></tr></tbody></table></blockquote><h4>4.4<tt>&nbsp;</tt><a name="(part._.Late_.Binding_of_.Self_and_.Modularity)"></a>Late Binding of Self and Modularity</h4><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>See <a href="http://www.dreamsongs.com/NewFiles/WhyOfY.pdf">the Why of Y</a>.</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">In the definition of the <span class="RktSym">OBJECT-DEL</span> syntactic abstraction, notice that we use, in the definition of message sending, the self-application pattern <span class="RktPn">(</span><span class="RktSym">obj</span><span class="stt"> </span><span class="RktSym">obj</span><span class="RktPn">)</span>. This is similar to the self application pattern we have seen to achieve recursive binding without mutation.</div><p></p><p></p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Think about what you know from mainstream languages like C++ and Java: what means do these two languages provide to address this tradeoff between extensibility and fragility?</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">This feature of OOP is also known as "open recursion": any sub-object can redefine the meaning of a method in one of its parents. Of course, this is a mechanism that favors <span style="font-style: italic">extensibility</span>, because it is possible to extend any aspect of an object without having to foresee that extension. On the other hand, open recursion also makes software more <span style="font-style: italic">fragile</span>, because it becomes extremely easy to extend an object in unforeseen, incorrect ways. Imagine scenarios where this can be problematic and think about possible alternative designs.
To shed some more light on fragility, think about black-box composition of objects: taking two objects, developed independently, and then putting them in a delegation relation with each other. What issues can arise?</div><p></p><h4>4.5<tt>&nbsp;</tt><a name="(part._.Lexical_.Scope_and_.Delegation)"></a>Lexical Scope and Delegation</h4><p></p><div class="SIntrapara">As we have seen previously, we can define <a href="https://users.dcc.uchile.cl/~etanter/ooplai/self.html#%28part._nested%29" data-pltdoc="x">nested objects</a> in our system. It is interesting to examine the relation between lexical nesting and delegation.
Consider the following example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0"><tbody><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">parent</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">foo</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">outer</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">root</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">field</span><span class="hspace">&nbsp;</span><span class="RktSym">foo</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">λ</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">foo</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">get</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">OBJECT-DEL</span><span class="hspace">&nbsp;</span><span class="RktSym">parent</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">get-foo1</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">foo</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym">method</span><span class="hspace">&nbsp;</span><span class="RktSym">get-foo2</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">self</span><span class="hspace">&nbsp;</span><span class="RktSym">foo</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym">define</span><span class="hspace">&nbsp;</span><span class="RktSym">inner</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">outer</span><span class="hspace">&nbsp;</span><span class="RktSym">get</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></tbody></table></td></tr><tr><td><p>&nbsp;</p></td></tr><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tbody><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">inner</span><span class="hspace">&nbsp;</span><span class="RktSym">get-foo1</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">2</span></p></td></tr><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">inner</span><span class="hspace">&nbsp;</span><span class="RktSym">get-foo2</span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">1</span></p></td></tr></tbody></table></td></tr></tbody></table></blockquote></div><div class="SIntrapara">As you can see, a free identifier is looked up in the lexical environment (see <span class="RktSym">get-foo1</span>), while an unknown message is looked up in the chain of delegation (see <span class="RktSym">get-foo2</span>). This is important to clarify, because Java programmers are used to the fact that <span class="RktSym">this.foo</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span> is the same as <span class="RktSym">foo</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span>. In various languages that combine lexical nesting and some form of delegation (like inheritance), this is not the case.</div><p></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Other languages have different take on the question. Check out for Newspeak and AmbientTalk.</p></blockquote></blockquote></blockquote><p>So what happens in Java? Try it! You will see that the inheritance chain shadows the lexical chain: when using <span class="RktSym">foo</span><span class="stt"> </span><span class="RktPn">(</span><span class="RktPn">)</span> if a method can be found in a superclass, it is invoked; only if there is no method found, the lexical environment (i.e., the outer object) is used. Referring to the outer object is therefore very fragile. This is why Java also supports an additional form <span class="RktSym">Outer.this</span> to refer to the enclosing object. Of course, then, if the method is not found directly in the enclosing object’s class, it is then looked up in its superclass, rather than upper in the lexical chain.</p><h4>4.6<tt>&nbsp;</tt><a name="(part._.Delegation_.Models)"></a>Delegation Models</h4><p>The delegation model we have implemented here is but one point in the design space of prototype-based languages. Study the documentation of Self, JavaScript, and AmbientTalk to understand their designs. You can even modify our object system to support a different model, such as the JavaScript model.</p><h4>4.7<tt>&nbsp;</tt><a name="(part._.Cloning)"></a>Cloning</h4><p>In our language, as in JavaScript, the way to create objects is <span style="font-style: italic">ex-nihilo</span>: either we create an object from scratch, or we have a function whose role is to perform these object creations for us. Historically, prototype-based languages (like Self) have provided another way to create objects: by cloning existing objects. This approach emulates the copy-paste-modify metaphor we use so often with text (including code!): start from an object that is almost as you need, clone it, and modify the clone (eg. add a method, change a field).</p><p>When cloning objects in presence of delegation, the question of course arises of whether the cloning operation should be <span style="font-style: italic">deep</span> or <span style="font-style: italic">shallow</span>. Shallow cloning returns a new object that delegates to the same parent as the original object. Deep cloning returns a new object that delegates to a clone of the original parent, and so on: the whole delegation chain is cloned.</p><p>We won’t study cloning in more details in this course. You should however wonder how easy it would be to support cloning in our language. Since objects are in fact compiled into procedures (through macro expansion), the question boils down to cloning closures. Unfortunately, Scheme does not support such an operation. This is a case where the mismatch between the source and target languages shows up (recall Chapter 11 of PLAI). Nothing is perfect!</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/adt-oo.html" title="backward to &quot;3 Benefits and Limits of Objects&quot;" data-pltdoc="x">← prev</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/index.html" title="up to &quot;Object-Oriented Programming Languages: Application and Interpretation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="https://users.dcc.uchile.cl/~etanter/ooplai/Classes.html" title="forward to &quot;5 Classes&quot;" data-pltdoc="x">next →</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>